# -*- coding: utf-8 -*-
"""New_Algo_CG_3dhull.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XoY7xd_yKrYVg34jDEbHKm7qxAO4aekj
"""

import numpy as np

num_points = 100
points = np.random.rand(num_points, 3)
points=points.tolist()
print(points)
print(type(points))

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x=[i[0] for i in points]
y=[i[1] for i in points]
z=[i[2] for i in points]
ax.scatter(x,y,z)
plt.show()

u=(1,2,3)
u=list(u)
print(u)

n=len(points)

map={}
for i in points:
  map[tuple(i)]=[]
flag=0
for i in range(0,n-2):
  for j in range(i+1,n-1):
    for k in range(j+1,n):
      t1=(points[j][1]-points[i][1])*(points[k][2]-points[i][2])-(points[j][2]-points[i][2])*(points[k][1]-points[i][1])
      t2=(points[j][2]-points[i][2])*(points[k][0]-points[i][0])-(points[j][0]-points[i][0])*(points[k][2]-points[i][2])
      t3=(points[j][0]-points[i][0])*(points[k][1]-points[i][1])-(points[j][1]-points[i][1])*(points[k][0]-points[i][0])
      if t1==0 and t2==0 and t3==0:
        continue
      else:

        map[tuple(points[i])].append(tuple(points[j]))
        map[tuple(points[j])].append(tuple(points[i]))
        map[tuple(points[i])].append(tuple(points[k]))
        map[tuple(points[k])].append(tuple(points[i]))
        map[tuple(points[j])].append(tuple(points[k]))
        map[tuple(points[k])].append(tuple(points[j]))
        flag=1
        print(i,j,k)
        break
    if flag==1:
      break
  if flag==1:
    break

print(map)

mape={}
inc=[]
tri=[]
for i in points:
  if map[tuple(i)]==[]:
    inc.append(i)
  else:
    tri.append(i)
mape[(tuple(tri[0]),tuple(tri[1]))]=[tri[2]]
mape[(tuple(tri[0]),tuple(tri[2]))]=[tri[1]]
mape[(tuple(tri[1]),tuple(tri[2]))]=[tri[0]]
print(mape)
print(inc)
print(tri)

import numpy as np
def vsign(a,b,c,p):
  x=[0,0,0]
  y=[0,0,0]
  z=[0,0,0]
  x[0]=a[0]-p[0]
  x[1]=a[1]-p[1]
  x[2]=a[2]-p[2]
  y[0]=b[0]-p[0]
  y[1]=b[1]-p[1]
  y[2]=b[2]-p[2]
  z[0]=c[0]-p[0]
  z[1]=c[1]-p[1]
  z[2]=c[2]-p[2]
  vol=x[0]*(y[1]*z[2]-y[2]*z[1])-x[1]*(y[0]*z[2]-y[2]*z[0])+x[2]*(y[0]*z[1]-y[1]*z[0])
  if vol>0:
    return 1
  elif vol<0:
    return -1
  else:
    return 0

def vis(a,b,c,p,cen):
  cross=[(b[1]-a[1])*(c[2]-b[2])-(c[1]-b[1])*(b[2]-a[2]),(c[0]-b[0])*(b[2]-a[2])-(b[0]-a[0])*(c[2]-b[2]),(b[0]-a[0])*(c[1]-b[1])-(c[0]-b[0])*(b[1]-a[1])]
  vec=[b[0]-cen[0],b[1]-cen[1],b[2]-cen[2]]
  dot=cross[0]*vec[0]+cross[1]*vec[1]+cross[2]*vec[2]
  if dot>0:
    return vsign(a,b,c,p)
  else:
    return vsign(a,c,b,p)


print(vis([0,0,0],[0,0,1],[0,1,0],[1/2,1/2,1/2],[0.1875, 0.375, 0.28125]))


def vecsi(a,b,c,cen):
  cross=[(b[1]-a[1])*(c[2]-b[2])-(c[1]-b[1])*(b[2]-a[2]),(c[0]-b[0])*(b[2]-a[2])-(b[0]-a[0])*(c[2]-b[2]),(b[0]-a[0])*(c[1]-b[1])-(c[0]-b[0])*(b[1]-a[1])]
  vec=[b[0]-cen[0],b[1]-cen[1],b[2]-cen[2]]
  dot=cross[0]*vec[0]+cross[1]*vec[1]+cross[2]*vec[2]
  if dot>0:
    return 1
  else:
    return -1

n=len(points)

map={}
for i in points:
  map[tuple(i)]=[]
flag=0
for i in range(0,n-2):
  for j in range(i+1,n-1):
    for k in range(j+1,n):
      t1=(points[j][1]-points[i][1])*(points[k][2]-points[i][2])-(points[j][2]-points[i][2])*(points[k][1]-points[i][1])
      t2=(points[j][2]-points[i][2])*(points[k][0]-points[i][0])-(points[j][0]-points[i][0])*(points[k][2]-points[i][2])
      t3=(points[j][0]-points[i][0])*(points[k][1]-points[i][1])-(points[j][1]-points[i][1])*(points[k][0]-points[i][0])
      if t1==0 and t2==0 and t3==0:
        continue
      else:

        map[tuple(points[i])].append(points[j])
        map[tuple(points[j])].append(points[i])
        map[tuple(points[i])].append(points[k])
        map[tuple(points[k])].append(points[i])
        map[tuple(points[j])].append(points[k])
        map[tuple(points[k])].append(points[j])
        flag=1
        print(i,j,k)
        break
    if flag==1:
      break
  if flag==1:
    break

print(map)
mape={}
inc=[]
tri=[]
for i in points:
  if map[tuple(i)]==[]:
    inc.append(i)
  else:
    tri.append(i)
mape[(tuple(tri[0]),tuple(tri[1]))]=[tri[2]]
mape[(tuple(tri[0]),tuple(tri[2]))]=[tri[1]]
mape[(tuple(tri[1]),tuple(tri[2]))]=[tri[0]]
print(mape)
print(inc)
print(tri)

print(len(inc))

while len(inc)>0:
  p=inc.pop()
  cen=[0,0,0]
  for i in tri:
    cen[0]+=i[0]
    cen[1]+=i[1]
    cen[2]+=i[2]
  cen=[i/len(tri) for i in cen]
  flag=0
  partial=[]
  remove=[]

  for i in mape:

    vi=0
    inv=0
    if len(mape[i])==1:
      mape[i].append(p)
      partial.append(i)
      flag=1
      continue
    t=[]
    for j in mape[i]:
      print(i,j,p,cen,vis(list(i[0]),list(i[1]),j,p,cen))
      if vis(list(i[0]),list(i[1]),j,p,cen) ==1:
        inv=inv+1
      elif vis(list(i[0]),list(i[1]),j,p,cen) ==-1:
        if len(mape[i])==2:
          t.append(j)

        vi=vi+1

    for j in t:
      mape[i].remove(j)
    if (vi==1 and inv==1) or (vi==1 and inv==0):
      mape[i].append(p)
      partial.append(i)
      flag=1
    elif vi==2 and inv==0:
      remove.append(i)
      flag=1
  print(flag)
  q=[]
  for i in partial:
    q.append(i[0])
    q.append(i[1])
  q=list(set(q))
  if flag==1:
    tri.append(p)
    for i in q:
      mape[(i,tuple(p))]=[]
      map[i].append(p)
      map[tuple(p)].append(list(i))
    for i in partial:
      mape[i[0],tuple(p)].append(i[1])
      mape[i[1],tuple(p)].append(i[0])
    for i in remove:
      del mape[i]
      map[i[0]].remove(list(i[1]))
      map[i[1]].remove(list(i[0]))

print(mape)

cen = [0, 0, 0]
for i in points:
    cen[0] += i[0]
    cen[1] += i[1]
    cen[2] += i[2]
cen = [i / len(points) for i in cen]


triangles = []


for edge, connected_vertices in mape.items():
    v1, v2 = edge
    for v3 in connected_vertices:
        triangle = [tuple(v1), tuple(v2), tuple(v3)]
        triangle_sorted = sorted(triangle)
        triangles.append(triangle_sorted)


triangles = [list(tri) for tri in set(tuple(tri) for tri in triangles)]


triangles_sorted = sorted(triangles, key=lambda x: x[0])


for tri in triangles_sorted:
    print(tri)


print(triangles_sorted)

pip install numpy-stl

import numpy as np
from stl import mesh
ordered=[]
for i in triangles_sorted:
  if vecsi(i[0],i[1],i[2],cen)==1:
    ordered.append([i[0],i[1],i[2]])
  else:
    ordered.append([i[0],i[2],i[1]])
print(len(ordered))

vertices = []
faces = []

for triangle in ordered:
    for vertex in triangle:
        vertices.append(vertex)

    base_index = len(faces) * 3
    faces.append([base_index, base_index + 1, base_index + 2])


vertices = np.array(vertices)
faces = np.array(faces)


your_mesh = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))


for i, f in enumerate(faces):
    for j in range(3):
        your_mesh.vectors[i][j] = vertices[f[j], :]


your_mesh.save('output+.stl')

print("STL file created successfully!")

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
x=[i[0] for i in points]
y=[i[1] for i in points]
z=[i[2] for i in points]
ax.scatter(x,y,z,color='b')
for i in mape:
  plt.plot([i[0][0],i[1][0]],[i[0][1],i[1][1]],[i[0][2],i[1][2]],'r')

plt.show()